%----------------------------------------------------------------------------------------
%	INTELLIGENZA ARTIFICIALE DEI GIOCATORI
%----------------------------------------------------------------------------------------

\section*{IA dei giocatori}
\addcontentsline{toc}{section}{\protect\numberline{}IA dei giocatori}%
\label{sec:ai_giocatori}
In questa sezione viene descritta la struttura dell'intelligenza artificiale dei giocatori.

% Programmazione Logica: Prolog
\subsection{Programmazione Logica: Prolog}
Per creare il sistema decisionale dei giocatori utilizzeremo Prolog, un linguaggio di programmazione che trova le sue radici nella logica del primo ordine.
\footnote{Durante lo sviluppo del progetto \`{e} stato utilizzato SWI-Prolog, un'implementazione open source di Prolog compatibile con ogni piattaforma e che mette a disposizione un ampio set di tools per lo sviluppo. Sito ufficiale: \href{http://www.swi-prolog.org/}{http://www.swi-prolog.org}.}.
Essendo un linguaggio di programmazione ispirato alla logica del primo ordine, un programma scritto in Prolog \`{e} un insieme di predicati formati da una concatenazione di \emph{precondizioni}, ovvero dei fatti che devono essere tutti veri affinch\`{e} la \emph{testa} della clausola sia vera.

Prolog risolve le clausole utilizzando l'inferenza logica in maniera molto efficiente, ma senza nessun controllo su cicli o cammini infiniti. Ci\`{o} lo rende molto veloce se gli viene fornito un corretto insieme di clausole, ma incompleto altrimenti. Infatti la politica adottata da Prolog \`{e} quella di ``scaricare'' sul programmatore la responsabilit\`{a} di scrivere programmi corretti ed efficienti.\\

\subsection{Struttura dell'IA}
\label{sec:struct_ia}
In questa sezione viene analizzata la struttura dell'intelligenza artificale creata in Prolog.

Il sistema \`{e} diviso in due parti principali ciascuna delle quali \`{e} composta da una serie di predicati logici scritti in Prolog.

La prima parte \`{e} formata da predicati che descrivono quello che il giocatore sa riguardo a ci\`{o} che lo circonda, detta anche \emph{base di conoscenza}. Per ottenere tali predicati ciascun giocatore deve procurarsi informazioni riguardanti la situazione in prossimit\`{a} della sua posizione (quali la sua posizione, quale squadra ha la palla, quali giocatori sono vicini a lui e cos\`{i} via) interrogando lo stato.  In seguito, un apposito algoritmo implementato all'interno del giocatore si preoccuper\`{a} di convertire tali informazioni in predicati logici scritti secondo i formalismi di Prolog. Cos\`{i} facendo ciascun giocatore creer\`{a} una serie di predicati concantenati che formeranno la suddetta base di conoscenza, la quale viene presa in input dalla seconda parte del sistema, al fine di decidere l'azione pi\`{u} adeguata alla situazione corrente.

La seconda parte del sistema \`{e} formata da predicati che rappresentano le azioni che i giocatori possono effettuare. Questa parte \`{e} a sua volta suddivisa in tre categorie principali:
\begin{itemize}
\item \emph{Actions}: contiene tutte le clausole riguardanti le azioni che un giocatore `normale' pu\`{o} effettuare. Le categorie di azioni a disposizione di un giocatore sono passaggio (\emph{pass}), tiro (\emph{shot}), movimento (\emph{move}), contrasto (\emph{tackle}) e `prendi la palla' (\emph{catch}); 
\item \emph{Keeper}: comprende le azioni che il giocatore pu\`{o} fare se assume il ruolo di portiere. Il motivo dell'introduzione di questa distinzione tra giocatore `normale' e portiere \`{e}  che il primo non solo ha a disposizione pi\`{u}  azioni possibili rispetto al secondo, ma ha anche un comportamento differente. Ci\`{o}  non dovrebbe sorprendere visto che durante la partita il portiere sta la maggior parte del tempo fermo nella sua porta, mentre un giocatore normale si sposta nel campo ed interagisce con altri giocatori molto pi\`{u}  spesso. Inoltre alcuni eventi di gioco non interessano minimamente il portiere, come ad esempio una rimessa laterale o un semplice calcio di punizione eseguito vicino alla met\`{a}  campo, mentre il giocatore normale potrebbe dover spostarsi in una posizione particolare a causa di essi. Le azioni contenute in questo file sono quindi in numero minore e, in alcuni casi, eseguite diversamente. Per tutti questi motivi \`{e}  stato ritenuto opportuno utilizzare un set di azioni `personalizzato' solo per il portiere, nel qual caso durante l'esecuzione del programma i predicati in `Keeper' verranno utilizzati al posto dei predicati in `Actions';
\item \emph{Utilities}: contiene clausole ausiliarie utilizzate dai predicati in `Actions' e `Keeper'. Alcuni esempi di clausole ausiliarie sono l'aggiunta di un elemento ad una lista, il calcolo della distanza tra due punti e il calcolo della corretta coppia di coordinate in cui spostarsi. Queste clausole sono state inserite in un modulo distinto per facilitare la comprensione del programma finale.
\end{itemize}
\noindent Le azioni che possono essere scelte dal giocatore in un dato momento sono determinate dallo stato della partita, dalla presenza di eventi specifici (rimessa, punizione e cos√¨ via) e dalla situazione specifica nelle vicinanze del giocatore. Pi\`{u} precisamente, l'azione da compiere in un dato istante \`{e} il risultato di un'inferenza logica effettuata sulle clausole incluse nella base di conoscenza del giocatore, ovvero sull'input ricevuto dalla prima parte del sistema.

\subsection{Workflow}
Il processo decisionale che porta il giocatore ad eseguire un'azione \`{e} quindi il seguente:
\begin{enumerate}
 \item Il giocatore interroga lo stato per ottenere informazioni riguardanti le sue immediate vicinanze e lo stato complessivo della partita;
 \item Un algoritmo dedicato interno al giocatore provvede a convertire le informazioni ottenute dallo stato in clausole logiche scritte secondo i formalismi di Prolog; 
 \item Viene lanciato il programma Prolog descritto in Sezione \ref{sec:struct_ia} fornendo come input la concatenazione di clausole cos\`{i} ottenuta al passo precedente;
 \item Prolog esegue un inferenza logica sull'input ricevuto al passo precedente e fornisce in ouput la mossa ottimale per il giocatore data la situazione corrente;
 \end{enumerate} 
